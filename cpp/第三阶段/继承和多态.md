[TOC]

# 继承和多态

# 单继承

## 1.语法示例：

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
    int move_tel;
public:
    int id;
    string name;
protected:
    int tel;
};
class Master :public Student {
    string topic;
public:
    void add() {
        id = 20190101; tel = 12345678; dept = "Software";
        major = "Security"; topic = "IDS";
    }
    string dept;
protected:
    string major;
};
int main() {
    Master a;  a.id = 20190101; a.dept = "Software";  a.add();
    return 0;
}

```

## 2.访问权限：

注意：这里的改变，是对内的改变，对外无论什么继承方式，派生类都能访问基类原先是public和protected的数据成员。

### public继承的访问权限：

![1713233683767](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713233683767.png)

示例：

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
    int m3;
public:
    int m1;  void x() { m1 = 1; m2 = 2; m3 = 3; }
protected:
    int m2;
};
class Master :public Student {
    int n3;
public:
    void y() { m1 = 1; m2 = 2; m3 = 3; n1 = 1; n2 = 2; n3 = 3; }    //对内,m3=3错误
    void z() { x(); }    //间接访问了父类的private成员
    int n1;
protected:
    int n2;
};
int main() {
    Master a;
    a.m1 = 1; a.m2 = 2; a.m3 = 3; a.n1 = 1; a.n2 = 2; a.n3 = 3;   //对外，只有m1,n1可以正常访问
    a.x();
    a.z();
    return 0;
}
```

### protected和private继承的访问权限：

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
    int move_tel;
public:
    int id;
    string name;
protected:
    int tel;
};
class Master :protected Student {
    string topic;
public:
    string dept;
protected:
    string major;
};
int main() {
    Master a;
    return 0;
}
//Public: dept    protected:id, name, tel, major;
```

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
	int move_tel;
public:
	int id;
	string name;
protected:
	int tel;
};
class Master :private Student {
	string topic;
public:
	string dept;
protected:
	string major;
};
int main() {
	Master a;
    return 0;
}
//Public: dept    protected: major;  private:id, name, tel, topic，move_tel
```

![1713234438070](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713234438070.png)

## 3.继承的本质：

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
public:
	int m1;
protected:
	int m2;
private:
	int m3;
};
class Master :public Student {
public:
	int n1;
protected:
	int n2;
private:
	int n3;
};
class MasterEnginee :public Master {
public:
	int p1;
protected:
	int p2;
private:
	int p3;
};

int main() {
	MasterEnginee a;
    return 0;
}
```

继承的本质实际上就是由上到下完全的复制；但是在对内可见性上做了手脚，对外可见性则没有改变。

## 4.父子类和相互转换判断：

### **public继承**父类对象可以被子类对象代替，反之不可：

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
    int m3;
public:   int m1;  void x() { m1 = 1; m2 = 2; m3 = 3; }
protected:   int m2;
};
class Master :public Student {
    int n3;
public: int n1;  void y() { m1 = 1; m2 = 2; n1 = 1; n2 = 2; n3 = 3; }
protected:  int n2;
};
void f(Student& a) { a.m1 = 5; a.n1 = 6; a.x(); a.y(); }//a.n1和a.y()错误，父类访问子类成员
int main() {
    Master a;
    Student* p = &a; p->m1 = 1; p->n1 = 2; p->x(); p->y();//p->n1和p->y()错误，父类访问子类成员
    f(a);
    Student b;
    b = a;
    return 0;
}
```

```c++
class Student {
	int m3;
public:   int m1;  void x() { m1 = 1; m2 = 2; m3 = 3; }
protected:   int m2;
};
class Master :public Student {
	int n3;
public: int n1;  void y() { m1 = 1; m2 = 2; n1 = 1; n2 = 2; n3 = 3; }
protected:  int n2;
};
void f(Master& a) { 
	//
}
int main() {
	Student a;  Master b;
	f(a);//错误
	Master* p = &a;//错误
	b = a;//错误
	return 0;
}
```

### protected和private继承得到的类都不是子类，“凡是父类对象可以出现的地方可以用子类对象代替”，不再适用：

```c++
class Student {
	int m3;
public:   int m1; void x() { m1 = 1; m2 = 2; m3 = 3; }
protected:   int m2;
};
class Master :protected Student {
	int n3;
public: int n1; void y() { m1 = 1; m2 = 2; n1 = 1; n2 = 2; n3 = 3; }
protected:  int n2;
};
void f(Student& a) {}
void main()
{
	Master a;
	a.x();//错误
	f(a);//错误
	Student* p = &a;//错误
}
```

## 5.继承类型省略时默认为私有继承

## 6.命名空间对继承访问权限的影响：

```c++
class Student {
    int move_tel;
public:
    int id;   string name;
protected:
    int tel;
};
class Master:public Student {
    string topic;
    using Student::id;
public:
    string dept;
    using Student::tel;
    using Student::move_tel;//错误
protected:
    string major;
};
int main() {
    Master a;
    a.id = 1;//错误  
    a.tel = 2;//正确
    return 0;
}
```

## 7.继承和组合之间的关联

```c++
class Student {
    int move_tel;
public:
    int id;
    void r() { 
        dept = "软件"; //×
    }
protected:
    int tel;
};
class Master :public Student {
    string topic;
public:
    string dept;
    void x() {
        id = 1;                       // √
        tel = 2;                   //    √
        move_tel = 3;      //     ×
    }
protected:    void y() {}
};
void main() {
    Master a;
    Student* p = &a;       // √
        a.id = 1;                      //√
        a.dept = "软件";       //√
        a.tel = 2;                  //  ×
        a.move_tel = 3;       //  ×
        a.topic = "网络";   //   ×
        a.y();                      // ×
}
```

```c++
class Student {
    int move_tel;
public:
    int id;
    void r(Master&);
protected:
    int tel;
};
class Master {
    string topic;
    Student s;
public:
    void x() {
        s.id = 1;                  //√
        s.tel = 2;              //   ×
        s.move_tel = 3;    //  ×
    }
protected:
    void y() {}
};
int Student::r(Master& t) {
    t.x();                          // √
    t.y();                        //  ×
    cout << t.topic;        //  ×
}
int main() {
    Master a;
    Student* p = &a;       // ×

    a.x();                          // √
    a.y();                         // ×
    cout << a.topic;         // ×

    cout << a.s.X;           //  ×
    return 0;
}//类似继承方式
```

### 组合的访问权限：

![1713236427871](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713236427871.png)

### 组合和继承都是实现复用的手段；尽量使用组合，因为是黑箱复用依赖较少 ，去掉继承关系，对象接口不变

```c++
class B {
public:
	void f() const { }
};
//class D : public B {
//public:
//	void func() const { f(); }
//};
class D {
public:
	void func() const { pb->f(); }
	D(B* p = new B) { pb = p; }
	operator B& () { return *pb; }
private:
	B* pb;
};
void F(const B& aB) {
	aB.f();
}
int main() {
	D d;
	d.func();
	F(d);
	return 0;
}
```

### 被组合的成员内部的成员和本级其他成员相互访问权限相当于类外关系

### 被组合成员内部的成员的成员的成员......外面对其访问权限属于逐级类外叠加的关系

## 8.继承后调用构造函数/析构函数案例：

继承的类的构造和析构函数的执行顺序遵循一定的规则，通常如下所述：

**构造函数执行顺序：**

1. **基类构造函数先于派生类构造函数被调用：**
   - 在派生类对象被创建时，首先会调用基类的构造函数，然后再调用派生类的构造函数。
   - 这意味着在构造派生类对象时，基类部分的成员变量和构造函数会优先被初始化和执行。

2. **构造函数调用顺序：**
   - 对于单继承情况下，构造函数的调用顺序是从最基类开始，逐级向派生类执行。
   - 具体执行顺序是：最顶层的基类构造函数 -> 下一级基类构造函数 -> ... -> 派生类构造函数。

**析构函数执行顺序：**

1. **派生类析构函数先于基类析构函数被调用：**
   - 在派生类对象被销毁时，首先会调用派生类的析构函数，然后再调用基类的析构函数。
   - 这意味着在析构派生类对象时，基类部分的资源释放会在派生类部分之后进行。

2. **析构函数调用顺序：**
   - 对于单继承情况下，析构函数的调用顺序是从派生类开始，逐级向上执行基类的析构函数。
   - 具体执行顺序是：派生类析构函数 -> 下一级基类析构函数 -> ... -> 最顶层的基类析构函数。

**示例说明：**

考虑以下类的继承关系：

正确:

```c++
#include <iostream>
using namespace std;
class A {
public:
    A() { cout << "A constructor" << endl; }
    virtual ~A() { cout << "A destructor" << endl; }
};

class B : public A {
public:
    B() { cout << "B constructor" << endl; }
    ~B() { cout << "B destructor" << endl; }
};
int main() {
    A* a = new B;
    delete a;
    return 0;
}
```

错误:

```c++
class A {
public:
    A() { cout << "A constructor" << endl; }
    ~A() { cout << "A destructor" << endl; }
};

class B : public A {
public:
    B() { cout << "B constructor" << endl; }
    ~B() { cout << "B destructor" << endl; }
};
```

当创建 `B` 类对象时，构造函数和析构函数的执行顺序如下：

- **构造 `B` 对象：**
   1. 调用 `A` 类的构造函数。
   2. 调用 `B` 类的构造函数。

- **销毁 `B` 对象：**
   1. 调用 `B` 类的析构函数。
   2. 调用 `A` 类的析构函数。

因此，继承关系中的构造函数和析构函数的执行顺序确保了基类部分先于派生类部分被初始化和析构，这样可以保证对象的正确构造和资源的正确释放。

```c++
class Student {
    int move_tel;
public:
    Student(int i) { tel = i; }
    int id;
    string name;
protected:
    int tel;
};
class Master :public Student {
    string topic;
public:
    Master(string p, int k) :Student(k) { major = p; }//Tel可以在Master的构造函数里初始化吗？ 可以，但是不提倡！

    string dept;
protected:
    string major;
};
int main() {
    Master a("Computer", 13512345678);
    return 0;
}
```

```c++
class Student {//如果父类中出现Master::tel形式的访问，错误！！！
	int move_tel;
public:
	Student(int i) { tel = i; cout << "student"<<endl; }   int id;
protected:
	int tel;    void O() { cout << tel << endl; }
};
class Master :public Student {
	string topic;
public:
	Master(int j, int k) :Student(k) { tel = j; cout << "master" << endl; }
	string dept;
	void O() { cout << tel << endl;  Student::O(); cout << Student::tel << endl; }
protected:
	int tel;
};
int main() {
	Master a(13312345, 13012345);  a.O();
    //构造函数、析构函数的执行顺序
	return 0; 
}
```

student
master
13312345
13012345
13012345

```c++
class A {
	int x;
public:
	A(int value = 0) :x(value) {}
	A(const A& s) :x(s.x) {}
	A& operator =(const A& s) { x = s.x; return *this; }
};
class B :public A {
	int y;
public:
	B(int v) :A(v), y(v) { }
	B(const B& s);
	B& operator=(const B& s);
};
B::B(const B& s) :A(s) { y = -1 * s.y; }
B& B::operator=(const B& s) {
	A::operator=(s);   y = -1 * s.y;   return(*this);//让this的x能等于s的x，让this的y能等于s的y
}
```

```c++
#include <iostream>
using namespace std;
#include <string>
class A {
public:
    A() { cout << "A" << endl; }
    ~A() { cout << "~A" << endl; }
};
class B { 
public:
    B() { cout << "B" << endl; }
    ~B() { cout << "~B" << endl; }
};
class C {  
public:
    C() { cout << "C" << endl; }
    ~C(){ cout << "~C" << endl; }
};
class D :public A {
    B b;
public:
  

    D() { cout << "D" << endl; }
    ~D() { cout << "~D" << endl; }
};
class E :public D {
    C c;
public:
    
    E() { cout << "E" << endl; }
    ~E() { cout << "~E" << endl; }
};
void f() {
    E e;
}
int  main() { f(); return 0; }
```

A
B
D
C
E
~E
~C
~D
~B
~A

## 9.继承中对象的管理->多态

### 管理者

![1713241811729](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713241811729.png)

![1713241842148](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713241842148.png)

### 分类讨论

![1713241977219](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713241977219.png)

#### （1）父类定义，子类继承

##### a.对象方式

![1713242162604](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242162604.png)

##### b.各自指针

![1713242207717](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242207717.png)

##### c.祖先指针

![1713242261280](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242261280.png)

#### （2）父类定义，子类变异

##### a.对象方式

![1713242324004](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242324004.png)

##### b.各自指针

![1713242354087](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242354087.png)

##### c.祖先指针（出现特殊情况：同化效应）

![1713242530837](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242530837.png)

基于多态，我们希望能够避免同化效应，输出机械变速和自动变速。

###### 解决方案：

###### 1.下策

###### ![1713242700490](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242700490.png)

###### 2.上策：虚函数

引入**虚函数**来支持**多态**

![1713242814849](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713242814849.png)

（delete）

## 10.抽象类  纯虚函数

```cpp
#include <iostream>
using namespace std;
class Student {//抽象类
    int id;
public:
    virtual void p() = 0;//纯虚函数
};
class Master :public Student {
    string dept;
public:
    void p() { cout << " Master "; }
};
class Mba :public Student {
    string  position;
public:
    virtual void p() { cout << " Mba "; }
};
void main() {
    //Student s; //错误  抽象类不可以实例化
    Master a;
    Mba b;
    Student* m = &a;   m->p();   //指针是目标
    m = &b;  m->p();
}//有些类没有独立于具体类存在的意义,纯粹为了抽象而存在
```

```cpp
class Student{
    int id;
public:
   virtual int p()=0;
};
class Master :public Student{//还是抽象类
    string dept;
};
class Mba :public  Master{//不是抽象类
    string  position;
public:
    virtual int p(){cout<< " Mba ";}
};
void main(){
   Student s; //错误  不可以实例化
   Master a; //错误  不可以实例化
   Mba b;
   Student *m; 
   m=&b;  
   m->p();
}
```

```cpp
class Student{
   int id;
public:
   virtual int p()=0;   
   virtual void q()=0;
};
class Master :public Student{//Master仍然是抽象类
    string dept;
public:
    int p(){cout<< " Master ";}
};
class MasterEnginee :public Master{//不再是抽象类
    string  position;
public:
    void q(){cout<< " MasterEnginee ";}
};

```

```c++
#include <iostream>
using namespace std;
class Student {
    int id;
public:
    virtual int p() = 0 { id = 9; cout << "id"; return id; };//可有代码，强行访问
    Student(int i = 9) { id = i; }
    ~Student() { cout << "析构" << endl; }
};
class Master :public Student {
    string dept;
};
class Mba :public  Master {
    string  position;
public:
    virtual int p() { cout << " Mba "; return 1; }
};
int main() {
    Mba m;
    m.Student::p(); //强行访问
    return 0;
}
```

id析构

### 总结：

#### 抽象类不可以实例对象，但是可以定义指针和引用

#### **纯虚函数直到被覆盖前所派生的类均为抽象类**

#### 抽象类需要有构造函数和析构函数吗？可以有

#### 抽象类使得数据结构更加清晰，更加贴近自然 

# 多重继承

```c++
#include <iostream>
using namespace std;
class Master {
    string  pratice;
public:
    int id;
};
class Phd {
    string  paper;
public:
    int id;
};
class M_p :public Master, public Phd {
public:
    float avg;
};
void main() {
    M_p a;
    Master* p = &a; Phd* q = &a;
    a.id = 1;  //错误,不知道指代谁
    a.Phd::id = 1; a.Master::id = 2;
}
```

```c++
#include <iostream>
using namespace std;
class Student {public: int id; void x(){}};
class Master :public Student {
   string  pratice;
};
class Phd :public Student {
   string  paper;
};
class M_p:public Master,public Phd {
public :
   float avg;
};
void main(){
   M_p a;
   a.id=1; //错误 
   a.x();//错误
   a.Phd::id=1;  a.Master::id = 1;
   a.Phd::x();  a.Master::x();
   a.Student::id=1; 
   Student * p=&a; //无法忍受
}

```

![1713594069614](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713594069614.png)

解决困境：

## 1.虚继承

```c++
#include <iostream>
using namespace std;
class Student { public: int id;  void x() {} };

class Master :virtual public Student {
   string  pratice;
};
class Phd :virtual public Student {
   string  paper;
};
class M_p:public Master,public Phd {
public :
   float avg;
};
void main(){
   M_p a;
   a.id=1;   
   a.Phd::id=1;  a.Master::id = 1;  a.Phd::x();  a.Master::x();
   a.Student::id=1;  a.x();
   Student * p=&a;   p->x(); p->id = 1;
}
```

在这段代码中，涉及了虚继承（virtual inheritance）。虚继承是 C++ 中用来解决菱形继承（diamond inheritance）问题的一种机制。

菱形继承问题指的是多重继承中的一种特殊情况，例如：

```
     A
    / \
   B   C
    \ /
     D
```

在这种继承关系中，如果 B 和 C 都继承自 A，而 D 继承自 B 和 C，那么 A 中的成员在 D 中就会有两份拷贝，这可能导致二义性和资源浪费。

虚继承就是为了解决这个问题而引入的机制。在虚继承中，被继承的基类的子类会共享同一个基类子对象的实例，而不是分别拥有各自的实例。这样可以避免菱形继承中的问题，确保基类在派生类中只有一个实例。

在你的代码中：

```cpp
class Master : virtual public Student {
   string practice;
};

class Phd : virtual public Student {
   string paper;
};

class M_p : public Master, public Phd {
   float avg;
};
```

`Master` 和 `Phd` 类都通过 `virtual` 关键字虚拟继承了 `Student` 类。这意味着无论 `M_p` 最终继承了哪个基类，`Student` 类中的成员 `id` 和 `x()` 只会有一份实例，而不会出现重复。

在使用虚继承时，派生类中的构造函数对虚基类的构造负责，并且派生类必须通过虚基类名字限定的方式来访问虚基类的成员。比如 `a.Phd::id` 和 `a.Master::id` 来分别访问 `Phd` 和 `Master` 类继承自 `Student` 的 `id` 成员。

总之，虚继承解决了菱形继承带来的二义性和资源重复的问题，确保派生类中只有一个虚基类的实例。

## 2.机制:隐藏指针指向一个类表

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
public:
    Student() { cout << "Student 构造！" << endl; }
    int id;
};
class Master :virtual public Student {         //机制:隐藏指针指向一个类表
    string pratice;
public:
    Master(string p) { pratice = p; cout << "Master 构造！" << endl; }
};
class Phd :virtual public Student {
    string paper;
public:
    Phd(string p) { paper = p; cout << "Phd 构造！" << endl; }
};
class M_p :public Master, public Phd {
    float avg;
public:
    M_p(string p, string q) :Phd(q), Master(p) { cout << "M_p 构造！" << endl; }
};
int main() {
    M_p a("c++", "KDD");
    return 0;
}
```

Student 构造！
Master 构造！
Phd 构造！
M_p 构造！

![1713954151174](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713954151174.png)

----

和单继承对比:

```c++
#include <iostream>
using namespace std;
#include <string>
class Student {
public:
    Student() { cout << "Student 构造！" << endl; }
    int id;
};
class Master :public Student {
    string pratice;
public:
    Master(string p) { pratice = p; cout << "Master 构造！" << endl; }
};
class Phd :public Student {
    string paper;
public:
    Phd(string p) { paper = p; cout << "Phd 构造！" << endl; }
};
class M_p :public Master, public Phd {
    float avg;
public:
    M_p(string p, string q) :Phd(q), Master(p) { cout << "M_p 构造！" << endl; }
};
void main() {
    M_p a("c++", "KDD");
}

```

Student 构造！
Master 构造！
Student 构造！
Phd 构造！
M_p 构造！

![1713954597999](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713954597999.png)

![1713954661395](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713954661395.png)

## 3.虚拟继承的基类构造函数被直接调用

```cpp
#include <iostream>
using namespace std;
#include <string>
class Student {
public:
    int id;
    Student(int s = 1) { id = s; cout << id << endl; }
};
class Master :virtual public Student {
    string  pratice;
public:
    Master(int s) :Student(s) { cout << id << endl; }
};
class M_p :public Master {
public:
    float avg;
    M_p(int s) :Master(s) { cout << id << endl; }
};

void main() {
    M_p a(9);                  //虚拟继承的基类构造函数被直接调用
}
```

1
1
1

## 4.隐藏指针的创建

```cpp
#include <iostream>
using namespace std;
#include <string>
//终结类
class Student {
    Student() {}//构造函数私有化
public:
    int id;
    friend class Master;
};
class Master :virtual public Student {
    string pratice;
public:
    Master() {}
};
class A :public Master {};
void main() {
    Master a;
    A x;            //错误
}
```

隐藏指针的创建需要构造函数。

```cpp
#include <iostream>
using namespace std;
#include <string>
//终结类
class Student {
protected:
    Student() {}
public:
    int id;
};
class Master :virtual protected Student {
    string pratice;
public:
    Master() {}
};
class A :public Master {};
void main() {
    Master a;
    A x;            //错误
}
```

注意：

虚拟继承和虚函数(多态、抽象类)没有关系

多重继承使用起来困难

实际问题基本可以避免多重继承

# 多态

## 1.多态体验与应用：

![1713428502439](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713428502439.png)

![1713428535499](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713428535499.png)

```c++
#include <iostream>
using namespace std;
class X {
public:
	virtual void f1() { cout << "Running X::f1()" << endl;  f4(); }
	virtual void f2() { cout << "Running X::f2()" << endl;  f3(); }
	virtual void f3() { cout << "Running X::f3()" << endl;  f4(); }
	virtual void f4() { cout << "Running X::f4()" << endl; }
};
class Y :public X {
public:
	void f1() { cout << "Running Y::f1()" << endl;   f2(); }
	void f3() { cout << "Running Y::f3()" << endl;   f4(); }
};
int main() {
	X& p = *(new Y);
	p.f1();
	return 0;
}
```

Running Y::f1()
Running X::f2()
Running Y::f3()
Running X::f4()

```c++
#include <iostream>
using namespace std;
class Fish {
    string KindName;
public:
    virtual void operation() { cout << KindName.c_str() << "做菜" << endl; }
    Fish(string name = "鲤鱼") :KindName(name) {}
};
class Cook :public Fish {
protected:
    Fish* process;
public:
    void cook(Fish* p) { process = p; };
    void operation() { process->operation(); }
};
class CookA :public Cook {
public:
    void operation() { process->operation(); cout << "煎-"; }
};
class CookB :public Cook {
public:
    void operation() { process->operation(); cout << "炒-"; }
};
class CookC :public Cook {
public:
    void operation() { process->operation(); cout << "烹-"; }
};

void main() {
    Fish* p = new Fish;
    Cook* qA = new CookA;
    Cook* qC = new CookC;
    Cook* qA1 = new CookA;
    Cook* qB = new CookB;
    qA->cook(p);
    qC->cook(qA);
    qA1->cook(qC);
    qB->cook(qA1);
    qB->operation();

    delete p, qA, qC, qA1,qB;
}

```

鲤鱼做菜
煎-烹-煎-炒-

## 2.装饰器：

组合+继承实现递归调用虚函数，实现装饰器作用。

![1713582447833](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713582447833.png)

装饰器有很多实际用途：
1.游戏开发中的武将。加一件装备就加武力值。

2.教室大门，时不时加一些修饰。

## 3.循环依赖

```c++
#include <iostream>
using namespace std;
class Case;
class StateB;
class State {
public:
	virtual void Turn(Case* pCase) {};
};
class Case {
	State* m_pState;
public:
	void ChangeState(State* pState);
	Case(State* p) { m_pState = p; }
	void Run() { m_pState->Turn(this); }
	virtual ~Case() {
		delete m_pState;
	}
};
void Case::ChangeState(State* pState)
{
	if (NULL != m_pState) {
		delete m_pState;
		m_pState = NULL;
	}
	m_pState = pState;
}
class StateA :public State {
	void Turn(Case* pCase) {
		cout << "春--";
		pCase->ChangeState(new StateB);
	}
};

class StateD :public State {
	void Turn(Case* pCase) {
		cout << "冬--";
		pCase->ChangeState(new StateA);
	}
};
class StateC :public State {
	void Turn(Case* pCase) {
		cout << "秋--";
		pCase->ChangeState(new StateD);
	}
};
class StateB :public State {
	void Turn(Case* pCase) {
		cout << "夏--";
		pCase->ChangeState(new StateC);
	}
};
void main() {
	Case* p = new Case(new StateA);
	for (int i = 0; i < 9; i++) {
		p->Run();
	}
		
	delete p;

}
```

**怎么解决？**

## 4.多态的意义：

   （1）是追求用指针管理继承体系对象的结果；
   （2）多态性使得应用程序使用类体系中的不同层次对象共存的复杂局面达到了一种可管理的境界；程序员从使用孤立的类，到使用分层的类，让各种对象“同场竞技”,并且能充分展现其个性。

   （3）不支持多态的语言不能称为面向对象的语言。

## 5.虚函数的工作机理：

![1713428759822](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713428759822.png)

![1713428924992](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713428924992.png)

![1713428935434](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713428935434.png)

![1713429038071](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713429038071.png)

？

![1713429494633](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713429494633.png)

## 6.析构函数要尽可能设置为虚函数

```c++
#include <iostream>
using namespace std;
class A {
	char* p;
public:
	A() { p = new char[5]; cout << "A" << endl; }
    ~A() { delete[] p; cout << "~A" << endl; }
};
class B :public A {
	char* q;
public:
	B() { q = new char[500]; cout << "B" << endl; }
	~B() { delete[] q; cout << "~B" << endl; }
};
void f() { A* p; p = new B; delete p; }
void main() {
	f(); f(); f();
}
```

A
B
~A
A
B
~A
A
B
~A

问题：没有释放B

```c++
#include <iostream>
using namespace std;
class A {
	char* p;
public:
	A() { p = new char[5]; cout << "A" << endl; }
    virtual ~A() { delete[] p; cout << "~A" << endl; }
};
class B :public A {
	char* q;
public:
	B() { q = new char[500]; cout << "B" << endl; }
	~B() { delete[] q; cout << "~B" << endl; }
};
void f() { A* p; p = new B; delete p; }
void main() {
	f(); f(); f();
}

```

A
B
~B
~A
A
B
~B
~A
A
B
~B
~A

```c++
#include <iostream>
using namespace std;

class A {
	char* p;
public:
	A() { p = new char[5]; cout << "A" << endl; }
	virtual ~A() { delete[] p; cout << "~A" << endl; }
};
class B :public A {
	char* q;
public:
	B() { q = new char[500]; cout << "B" << endl; }
	~B() { delete[] q; cout << "~B" << endl; }
};
void f() { A* p= new B; delete p; }
void main() {
	f(); f(); f();
}

```

A
B
~B
~A
A
B
~B
~A
A
B
~B
~A

## 7.构造函数、析构函数调用虚函数不支持多态

```c++
#include <iostream>
using namespace std;
class A {
    int i;
public:
    virtual void f() { cout << "父类" << endl; }
    void X() { f(); }
    ~A() { f(); }
};
class B :public A {
    int y;
public:
    void f() { cout << "子类" << endl; }
    void X() { f(); }
    ~B() { f(); }
};
void main() {
    A* p = new B;        
    p->X();
    delete p;
}

```

子类
父类

如果支持，答案应该为两行子类。

## 8.多态注意事项：

### 非成员、静态成员、内联函数不能是虚函数 

### **构造函数不能是虚函数** 

原因：由虚函数的工作机理，没有this指针是无法创建虚函数的，非成员函数、静态成员函数、内联函数、构造函数都没有this指针，因此不能是虚函数。

### 析构函数经常定义成虚函数  delete p;

## 9.一个拷贝的例子

```c++
#include <iostream>
using namespace std;
class Shape {
public:
	virtual double area(){}
};
class Circle :public Shape {
public:
	double area(){}
};
class Triangle :public Shape {
public:
	double area(){}
};
class Manage {
	Shape* a[100];
public:

};
```

要求完成Manage类的拷贝构造函数，实现深度拷贝；可以改动所有的类（你的操作）

```c++
#include <iostream>
using namespace std;

class Shape {
public:
    virtual ~Shape() {
        cout << "析构" << endl;
    } // 添加虚拟析构函数
    virtual double area() const = 0;
    virtual Shape* clone() const = 0; // 添加虚拟克隆函数
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() const override {
        return 3.14159 * radius * radius;
    }
    Circle* clone() const override {
        return new Circle(*this);
    }
};

class Triangle : public Shape {
private:
    double base;
    double height;
public:
    Triangle(double b, double h) : base(b), height(h) {}
    double area() const override {
        return 0.5 * base * height;
    }
    Triangle* clone() const override {
        return new Triangle(*this);
    }
};

class Manage {
private:
    Shape* a[100];
    int count;
public:
    Manage() : count(0) {}

    // 深度拷贝构造函数
    Manage(const Manage& other) : count(other.count) {
        for (int i = 0; i < count; ++i) {
            a[i] = other.a[i]->clone(); // 使用克隆函数进行深度拷贝
        }
    }

    // 添加图形
    void addShape(Shape* shape) {
        if (count < 100) {
            a[count++] = shape;
        }
    }

    // 打印所有图形的面积
    void printAreas() const {
        for (int i = 0; i < count; ++i) {
            cout << "Area of shape " << i + 1 << ": " << a[i]->area() << endl;
        }
    }

    // 析构函数，释放内存
    ~Manage() {
        for (int i = 0; i < count; ++i) {
            delete a[i];
        }
    }//c1,t1会再次也被释放
};

int main() {
    Manage manager;

    Circle* c1 = new Circle(2.0);
    Triangle* t1 = new Triangle(3.0, 4.0);

    manager.addShape(c1);
    manager.addShape(t1);

    // 使用拷贝构造函数创建新的 Manage 对象
    Manage managerCopy = manager;

    // 打印拷贝后的图形面积
    managerCopy.printAreas();

    return 0;
}

```

Area of shape 1: 12.5664
Area of shape 2: 6
析构
析构
析构
析构

# 类的六种关系

![1713956060282](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713956060282.png)

![1713956088045](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1713956088045.png)

# 设计原则

![1714742828151](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1714742828151.png)

1、单一职责

​     就一个类、接口、方法而言，应该仅有一个引起它变化的原因

2、开放封闭

​    软件的实体（类、模块、函数），对于扩展开放、对于修改关闭

3、依赖倒转（依赖倒置）

​    抽象（稳定）不应该依赖于细节（变化），细节（变化）应该依赖于抽象（稳定）；高层（稳定）也不依赖底层（变化），而共同依赖抽象（接口）（稳定）。

4、里氏替换

  把父类对象用子类对象代替，程序的行为没有变化。

5、合成聚合复用

​    尽量使用合成/聚合，对象组合，尽量不使用类继承

6、迪米特

   一个对象应该对其他对象有最少的了解。

7、接口隔离

​      依赖关系建立在最少的接口上      接口：类实例化对象、接口集合

程度而已！ 

案例：

![1714794268172](C:\Users\zhouhaoyang\AppData\Roaming\Typora\typora-user-images\1714794268172.png)

```cpp
#include <iostream>
using namespace std;
class Gps {
public:
    virtual void locat() {};
};
class GpsBeidou :public Gps {
public:
    void locat() {}
};
class GpsGalileo :public Gps {
public:
    void locat() {}
};
class Map {
public:
    virtual void navigat() {};
};
class MapBaidu :public Map {
public:
    void navigat() {}
};
class MapGaode :public Map {
public:
    void navigat() {}
};

class  Phone {
    Gps* part;//对象组合而不是类继承
public:
    Phone(Gps* ptr) { part = ptr; }
    void navigat(Map* ptr) {
        part->locat();
        ptr->navigat();
    }
};
void main() {
    Phone obj(new GpsBeidou);
    obj.navigat(new MapBaidu);
}

```

# 动态和静态类型转换

```cpp
#include <iostream>
using namespace std;
class M {};
class A {
public:
    virtual void x() {}
};
class B :public A {
public:
    void x() {}
};
class C :public B {
public:
    void x() {}
};
void main() {
    A* q = new B;
    C* p = dynamic_cast<C*>(q);
    if (p)//  此时p = = NULL;
        cout << " 指向成功" << endl;
}//继承体系内尝试指针与对象关联
```

```cpp
#include <iostream>
using namespace std;
class M {};
class A {
public:
    virtual void x() {}
};
class B :public A {
public:
    void x() {}
};
class C :public B {
public:
    void x() {}
};
void main() {
    A* q = new B;
    C* p = static_cast<C*>(q);
    if (p)//此时p为真
        cout << "指向成功" << endl;
}//继承体系下强制指针与对象关联
```

```cpp
class M{};
void x(const M *p){
    M * q;
    q = p;//扩大权限，因此不可以
    q = const_cast<M *>(p);//const修饰被去掉
    q = p;//仍然不可以，p本身没有被修改
}
```

 reinterpret_cast<T *>() 任意类型转换 胡作非为

https://docs.qq.com/document/DUlhsdkVyeFV1dlZI?file_id=%2Ff9c4c3ce-a582-402d-b360-672577d2c008&scene_file_id=%2Ff9c4c3ce-a582-402d-b360-672577d2c008&filename=C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB.pptx&scene_id=932651668&business_type=2&scene_type=2&filesize=0&bus_id=102&src_type=pptx&from=qunfile&tdsourcetag=pcqq_grpfile_list_preview&client=qq_files&third_appid=8622083aae9947b5b461fd03a42f1c6a